import boxen from "boxen";
import { diffWords } from "diff";
import { execa } from "execa";
import { existsSync, promises as fs } from "fs";
import { bold, cyan, dim, green, magenta } from "kleur/colors";
import ora from "ora";
import path from "path";
import preferredPM from "preferred-pm";
import prompts from "prompts";
import { fileURLToPath, pathToFileURL } from "url";
import { resolveConfigURL } from "../config.js";
import { debug, error, info } from "../logger/core.js";
import * as msg from "../messages.js";
import { printHelp } from "../messages.js";
import { appendForwardSlash } from "../path.js";
import { apply as applyPolyfill } from "../polyfill.js";
import { parseNpmName } from "../util.js";
import { generate, parse, t, visit } from "./babel.js";
import * as CONSTS from "./consts.js";
import { ensureImport } from "./imports.js";
import { wrapDefaultExport } from "./wrapper.js";
async function add(names, { cwd, flags, logging, telemetry }) {
  if (flags.help) {
    printHelp({
      commandName: "astro add",
      usage: "[FLAGS] [INTEGRATIONS...]",
      flags: [
        ["--yes", "Add the integration without user interaction."],
        ["--help", "Show this help message."]
      ]
    });
    return;
  }
  let configURL;
  const root = pathToFileURL(cwd ? path.resolve(cwd) : process.cwd());
  configURL = await resolveConfigURL({ cwd, flags });
  if (configURL == null ? void 0 : configURL.pathname.endsWith("package.json")) {
    throw new Error(`Unable to use astro add with package.json#astro configuration! Try migrating to \`astro.config.mjs\` and try again.`);
  }
  applyPolyfill();
  if (names.length === 0) {
    const response = await prompts([
      {
        type: "multiselect",
        name: "frameworks",
        message: "What frameworks would you like to enable?",
        instructions: "\n  Space to select. Return to submit",
        choices: CONSTS.FIRST_PARTY_FRAMEWORKS
      },
      {
        type: "multiselect",
        name: "addons",
        message: "What additional integrations would you like to enable?",
        instructions: "\n  Space to select. Return to submit",
        choices: CONSTS.FIRST_PARTY_ADDONS
      }
    ]);
    names = [...response.frameworks ?? [], ...response.addons ?? []];
  }
  if (names.length === 0) {
    error(logging, null, `No integrations specified.`);
    return;
  }
  names = names.map((name) => CONSTS.ALIASES.has(name) ? CONSTS.ALIASES.get(name) : name);
  if (configURL) {
    debug("add", `Found config at ${configURL}`);
  } else {
    info(logging, "add", `Unable to locate a config file, generating one for you.`);
    configURL = new URL("./astro.config.mjs", appendForwardSlash(root.href));
    await fs.writeFile(fileURLToPath(configURL), CONSTS.CONFIG_STUB, { encoding: "utf-8" });
  }
  const integrations = await validateIntegrations(names);
  let ast = null;
  try {
    ast = await parseAstroConfig(configURL);
    debug("add", "Parsed astro config");
    const defineConfig = t.identifier("defineConfig");
    ensureImport(ast, t.importDeclaration([t.importSpecifier(defineConfig, defineConfig)], t.stringLiteral("astro/config")));
    wrapDefaultExport(ast, defineConfig);
    debug("add", "Astro config ensured `defineConfig`");
    for (const integration of integrations) {
      await addIntegration(ast, integration);
      debug("add", `Astro config added integration ${integration.id}`);
    }
  } catch (err) {
    debug("add", "Error parsing/modifying astro config: ", err);
    throw createPrettyError(err);
  }
  let configResult;
  let installResult;
  if (ast) {
    try {
      configResult = await updateAstroConfig({ configURL, ast, flags, logging });
    } catch (err) {
      debug("add", "Error updating astro config", err);
      throw createPrettyError(err);
    }
  }
  switch (configResult) {
    case UpdateResult.cancelled: {
      info(logging, null, msg.cancelled(`Your configuration has ${bold("NOT")} been updated.`));
      return;
    }
    case UpdateResult.none: {
      const pkgURL = new URL("./package.json", configURL);
      if (existsSync(fileURLToPath(pkgURL))) {
        const { dependencies = {}, devDependencies = {} } = await fs.readFile(fileURLToPath(pkgURL)).then((res) => JSON.parse(res.toString()));
        const deps = Object.keys(Object.assign(dependencies, devDependencies));
        const missingDeps = integrations.filter((integration) => !deps.includes(integration.packageName));
        if (missingDeps.length === 0) {
          info(logging, null, msg.success(`Configuration up-to-date.`));
          return;
        }
      }
      info(logging, null, msg.success(`Configuration up-to-date.`));
      break;
    }
  }
  installResult = await tryToInstallIntegrations({ integrations, cwd, flags, logging });
  switch (installResult) {
    case UpdateResult.updated: {
      const len = integrations.length;
      if (integrations.find((integration) => integration.id === "tailwind")) {
        const possibleConfigFiles = [
          "./tailwind.config.cjs",
          "./tailwind.config.mjs",
          "./tailwind.config.js"
        ].map((p) => fileURLToPath(new URL(p, configURL)));
        let alreadyConfigured = false;
        for (const possibleConfigPath of possibleConfigFiles) {
          if (existsSync(possibleConfigPath)) {
            alreadyConfigured = true;
            break;
          }
        }
        if (!alreadyConfigured) {
          info(logging, null, `
  ${magenta(`Astro will generate a minimal ${bold("./tailwind.config.cjs")} file.`)}
`);
          if (await askToContinue({ flags })) {
            await fs.writeFile(fileURLToPath(new URL("./tailwind.config.cjs", configURL)), CONSTS.TAILWIND_CONFIG_STUB, { encoding: "utf-8" });
            debug("add", `Generated default ./tailwind.config.cjs file`);
          }
        } else {
          debug("add", `Using existing Tailwind configuration`);
        }
      }
      const list = integrations.map((integration) => `  - ${integration.packageName}`).join("\n");
      info(logging, null, msg.success(`Added the following integration${len === 1 ? "" : "s"} to your project:
${list}`));
      return;
    }
    case UpdateResult.cancelled: {
      info(logging, null, msg.cancelled(`Dependencies ${bold("NOT")} installed.`, `Be sure to install them manually before continuing!`));
      return;
    }
    case UpdateResult.failure: {
      throw createPrettyError(new Error(`Unable to install dependencies`));
    }
  }
}
async function parseAstroConfig(configURL) {
  const source = await fs.readFile(fileURLToPath(configURL), { encoding: "utf-8" });
  const result = parse(source);
  if (!result)
    throw new Error("Unknown error parsing astro config");
  if (result.errors.length > 0)
    throw new Error("Error parsing astro config: " + JSON.stringify(result.errors));
  return result;
}
const toIdent = (name) => {
  if (name.includes("-")) {
    return name.split("-")[0];
  }
  return name;
};
function createPrettyError(err) {
  err.message = `Astro could not update your astro.config.js file safely.
Reason: ${err.message}

You will need to add these integration(s) manually.
Documentation: https://docs.astro.build/en/guides/integrations-guide/`;
  return err;
}
async function addIntegration(ast, integration) {
  const integrationId = t.identifier(toIdent(integration.id));
  ensureImport(ast, t.importDeclaration([t.importDefaultSpecifier(integrationId)], t.stringLiteral(integration.packageName)));
  visit(ast, {
    ExportDefaultDeclaration(path2) {
      if (!t.isCallExpression(path2.node.declaration))
        return;
      const configObject = path2.node.declaration.arguments[0];
      if (!t.isObjectExpression(configObject))
        return;
      let integrationsProp = configObject.properties.find((prop) => {
        if (prop.type !== "ObjectProperty")
          return false;
        if (prop.key.type === "Identifier") {
          if (prop.key.name === "integrations")
            return true;
        }
        if (prop.key.type === "StringLiteral") {
          if (prop.key.value === "integrations")
            return true;
        }
        return false;
      });
      const integrationCall = t.callExpression(integrationId, []);
      if (!integrationsProp) {
        configObject.properties.push(t.objectProperty(t.identifier("integrations"), t.arrayExpression([integrationCall])));
        return;
      }
      if (integrationsProp.value.type !== "ArrayExpression")
        throw new Error("Unable to parse integrations");
      const existingIntegrationCall = integrationsProp.value.elements.find((expr) => t.isCallExpression(expr) && t.isIdentifier(expr.callee) && expr.callee.name === integrationId.name);
      if (existingIntegrationCall)
        return;
      integrationsProp.value.elements.push(integrationCall);
    }
  });
}
var UpdateResult = /* @__PURE__ */ ((UpdateResult2) => {
  UpdateResult2[UpdateResult2["none"] = 0] = "none";
  UpdateResult2[UpdateResult2["updated"] = 1] = "updated";
  UpdateResult2[UpdateResult2["cancelled"] = 2] = "cancelled";
  UpdateResult2[UpdateResult2["failure"] = 3] = "failure";
  return UpdateResult2;
})(UpdateResult || {});
async function updateAstroConfig({
  configURL,
  ast,
  flags,
  logging
}) {
  const input = await fs.readFile(fileURLToPath(configURL), { encoding: "utf-8" });
  let output = await generate(ast);
  const comment = "// https://astro.build/config";
  const defaultExport = "export default defineConfig";
  output = output.replace(` ${comment}`, "");
  output = output.replace(`${defaultExport}`, `
${comment}
${defaultExport}`);
  if (input === output) {
    return 0 /* none */;
  }
  let changes = [];
  for (const change of diffWords(input, output)) {
    let lines = change.value.trim().split("\n").slice(0, change.count);
    if (lines.length === 0)
      continue;
    if (change.added) {
      if (!change.value.trim())
        continue;
      changes.push(change.value);
    }
  }
  if (changes.length === 0) {
    return 0 /* none */;
  }
  let diffed = output;
  for (let newContent of changes) {
    const coloredOutput = newContent.split("\n").map((ln) => ln ? green(ln) : "").join("\n");
    diffed = diffed.replace(newContent, coloredOutput);
  }
  const message = `
${boxen(diffed, {
    margin: 0.5,
    padding: 0.5,
    borderStyle: "round",
    title: configURL.pathname.split("/").pop()
  })}
`;
  info(logging, null, `
  ${magenta("Astro will make the following changes to your config file:")}
${message}`);
  if (await askToContinue({ flags })) {
    await fs.writeFile(fileURLToPath(configURL), output, { encoding: "utf-8" });
    debug("add", `Updated astro config`);
    return 1 /* updated */;
  } else {
    return 2 /* cancelled */;
  }
}
async function getInstallIntegrationsCommand({
  integrations,
  cwd = process.cwd()
}) {
  const pm = await preferredPM(cwd);
  debug("add", `package manager: ${JSON.stringify(pm)}`);
  if (!pm)
    return null;
  let dependencies = integrations.map((i) => [[i.packageName, null], ...i.dependencies]).flat(1).filter((dep, i, arr) => arr.findIndex((d) => d[0] === dep[0]) === i).map(([name, version]) => version === null ? name : `${name}@${version}`).sort();
  switch (pm.name) {
    case "npm":
      return { pm: "npm", command: "install", flags: ["--save-dev"], dependencies };
    case "yarn":
      return { pm: "yarn", command: "add", flags: ["--dev"], dependencies };
    case "pnpm":
      return { pm: "pnpm", command: "install", flags: ["--save-dev"], dependencies };
    default:
      return null;
  }
}
async function tryToInstallIntegrations({
  integrations,
  cwd,
  flags,
  logging
}) {
  const installCommand = await getInstallIntegrationsCommand({ integrations, cwd });
  if (installCommand === null) {
    info(logging, null);
    return 0 /* none */;
  } else {
    const coloredOutput = `${bold(installCommand.pm)} ${installCommand.command} ${installCommand.flags.join(" ")} ${cyan(installCommand.dependencies.join(" "))}`;
    const message = `
${boxen(coloredOutput, {
      margin: 0.5,
      padding: 0.5,
      borderStyle: "round"
    })}
`;
    info(logging, null, `
  ${magenta("Astro will run the following command:")}
  ${dim("If you skip this step, you can always run it yourself later")}
${message}`);
    if (await askToContinue({ flags })) {
      const spinner = ora("Installing dependencies...").start();
      try {
        await execa(installCommand.pm, [installCommand.command, ...installCommand.flags, ...installCommand.dependencies], { cwd });
        spinner.succeed();
        return 1 /* updated */;
      } catch (err) {
        debug("add", "Error installing dependencies", err);
        spinner.fail();
        return 3 /* failure */;
      }
    } else {
      return 2 /* cancelled */;
    }
  }
}
async function validateIntegrations(integrations) {
  const spinner = ora("Resolving integrations...").start();
  const integrationEntries = await Promise.all(integrations.map(async (integration) => {
    const parsed = parseIntegrationName(integration);
    if (!parsed) {
      spinner.fail();
      throw new Error(`${integration} does not appear to be a valid package name!`);
    }
    let { scope = "", name, tag } = parsed;
    if (!name.startsWith("astro-")) {
      scope = `astrojs`;
    }
    const packageName = `${scope ? `@${scope}/` : ""}${name}`;
    const result = await fetch(`https://registry.npmjs.org/${packageName}/${tag}`).then((res) => {
      if (res.status === 404) {
        spinner.fail();
        throw new Error(`Unable to fetch ${packageName}. Does this package exist?`);
      }
      return res.json();
    });
    let dependencies = [
      [result["name"], `^${result["version"]}`]
    ];
    if (result["peerDependencies"]) {
      for (const peer in result["peerDependencies"]) {
        dependencies.push([peer, result["peerDependencies"][peer]]);
      }
    }
    return { id: integration, packageName, dependencies };
  }));
  spinner.succeed();
  return integrationEntries;
}
function parseIntegrationName(spec) {
  const result = parseNpmName(spec);
  if (!result)
    return;
  let { scope, name } = result;
  let tag = "latest";
  if (scope) {
    name = name.replace(scope + "/", "");
  }
  if (name.includes("@")) {
    const tagged = name.split("@");
    name = tagged[0];
    tag = tagged[1];
  }
  return { scope, name, tag };
}
async function askToContinue({ flags }) {
  if (flags.yes)
    return true;
  const response = await prompts({
    type: "confirm",
    name: "askToContinue",
    message: "Continue?",
    initial: true
  });
  return Boolean(response.askToContinue);
}
export {
  add as default,
  validateIntegrations
};
