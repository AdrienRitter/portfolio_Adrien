var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import glob from "fast-glob";
import fs from "fs";
import { bgGreen, bgMagenta, black, dim } from "kleur/colors";
import { fileURLToPath } from "url";
import * as vite from "vite";
import {
  createBuildInternals,
  trackClientOnlyPageDatas
} from "../../core/build/internal.js";
import { prependForwardSlash } from "../../core/path.js";
import { emptyDir, removeDir } from "../../core/util.js";
import { runHookBuildSetup } from "../../integrations/index.js";
import { rollupPluginAstroBuildCSS } from "../../vite-plugin-build-css/index.js";
import { info } from "../logger/core.js";
import { isBuildingToSSR } from "../util.js";
import { generatePages } from "./generate.js";
import { trackPageData } from "./internal.js";
import { getTimeStat } from "./util.js";
import { vitePluginHoistedScripts } from "./vite-plugin-hoisted-scripts.js";
import { vitePluginInternals } from "./vite-plugin-internals.js";
import { vitePluginPages } from "./vite-plugin-pages.js";
import { vitePluginSSR } from "./vite-plugin-ssr.js";
async function staticBuild(opts) {
  const { allPages, astroConfig } = opts;
  const pageInput = /* @__PURE__ */ new Set();
  const jsInput = /* @__PURE__ */ new Set();
  const facadeIdToPageDataMap = /* @__PURE__ */ new Map();
  const internals = createBuildInternals();
  const uniqueHoistedIds = /* @__PURE__ */ new Map();
  const timer = {};
  timer.buildStart = performance.now();
  for (const [component, pageData] of Object.entries(allPages)) {
    const astroModuleURL = new URL("./" + component, astroConfig.root);
    const astroModuleId = prependForwardSlash(component);
    trackPageData(internals, component, pageData, astroModuleId, astroModuleURL);
    if (pageData.route.type === "page") {
      const [renderers, mod] = pageData.preload;
      const metadata = mod.$$metadata;
      const clientOnlys = Array.from(metadata.clientOnlyComponentPaths());
      trackClientOnlyPageDatas(internals, pageData, clientOnlys);
      const topLevelImports = /* @__PURE__ */ new Set([
        ...metadata.hydratedComponentPaths(),
        ...clientOnlys,
        ...metadata.hydrationDirectiveSpecifiers(),
        ...renderers.filter((renderer) => !!renderer.clientEntrypoint).map((renderer) => renderer.clientEntrypoint)
      ]);
      const hoistedScripts = new Set(metadata.hoistedScriptPaths());
      if (hoistedScripts.size) {
        const uniqueHoistedId = JSON.stringify(Array.from(hoistedScripts).sort());
        let moduleId;
        if (uniqueHoistedIds.has(uniqueHoistedId)) {
          moduleId = uniqueHoistedIds.get(uniqueHoistedId);
        } else {
          moduleId = `/astro/hoisted.js?q=${uniqueHoistedIds.size}`;
          uniqueHoistedIds.set(uniqueHoistedId, moduleId);
        }
        topLevelImports.add(moduleId);
        if (internals.hoistedScriptIdToPagesMap.has(moduleId)) {
          const pages = internals.hoistedScriptIdToPagesMap.get(moduleId);
          pages.add(astroModuleId);
        } else {
          internals.hoistedScriptIdToPagesMap.set(moduleId, /* @__PURE__ */ new Set([astroModuleId]));
          internals.hoistedScriptIdToHoistedMap.set(moduleId, hoistedScripts);
        }
      }
      for (const specifier of topLevelImports) {
        jsInput.add(specifier);
      }
    }
    pageInput.add(astroModuleId);
    facadeIdToPageDataMap.set(fileURLToPath(astroModuleURL), pageData);
  }
  emptyDir(astroConfig.outDir, new Set(".git"));
  timer.clientBuild = performance.now();
  await clientBuild(opts, internals, jsInput);
  timer.ssr = performance.now();
  info(opts.logging, "build", isBuildingToSSR(astroConfig) ? "Building SSR entrypoints..." : "Building entrypoints for prerendering...");
  const ssrResult = await ssrBuild(opts, internals, pageInput);
  info(opts.logging, "build", dim(`Completed in ${getTimeStat(timer.ssr, performance.now())}.`));
  timer.generate = performance.now();
  if (opts.buildConfig.staticMode) {
    try {
      await generatePages(ssrResult, opts, internals, facadeIdToPageDataMap);
    } finally {
      await cleanSsrOutput(opts);
    }
  } else {
    info(opts.logging, null, `
${bgMagenta(black(" finalizing server assets "))}
`);
    await ssrMoveAssets(opts);
  }
}
async function ssrBuild(opts, internals, input) {
  var _a, _b, _c, _d;
  const { astroConfig, viteConfig } = opts;
  const ssr = isBuildingToSSR(astroConfig);
  const out = ssr ? opts.buildConfig.server : astroConfig.outDir;
  const viteBuildConfig = {
    logLevel: opts.viteConfig.logLevel ?? "error",
    mode: "production",
    css: viteConfig.css,
    optimizeDeps: {
      include: [...((_a = viteConfig.optimizeDeps) == null ? void 0 : _a.include) ?? []],
      exclude: [...((_b = viteConfig.optimizeDeps) == null ? void 0 : _b.exclude) ?? []]
    },
    build: __spreadProps(__spreadValues({}, viteConfig.build), {
      emptyOutDir: false,
      manifest: false,
      outDir: fileURLToPath(out),
      rollupOptions: {
        input: [],
        output: __spreadValues({
          format: "esm",
          entryFileNames: opts.buildConfig.serverEntry,
          chunkFileNames: "chunks/chunk.[hash].mjs",
          assetFileNames: "assets/asset.[hash][extname]"
        }, (_d = (_c = viteConfig.build) == null ? void 0 : _c.rollupOptions) == null ? void 0 : _d.output)
      },
      ssr: true,
      target: "esnext",
      minify: false,
      polyfillModulePreload: false,
      reportCompressedSize: false
    }),
    plugins: [
      vitePluginInternals(input, internals),
      vitePluginPages(opts, internals),
      rollupPluginAstroBuildCSS({
        internals,
        target: "server"
      }),
      ...viteConfig.plugins || [],
      isBuildingToSSR(opts.astroConfig) && vitePluginSSR(opts, internals, opts.astroConfig._ctx.adapter)
    ],
    publicDir: ssr ? false : viteConfig.publicDir,
    root: viteConfig.root,
    envPrefix: "PUBLIC_",
    server: viteConfig.server,
    base: astroConfig.base,
    ssr: viteConfig.ssr,
    resolve: viteConfig.resolve
  };
  await runHookBuildSetup({
    config: astroConfig,
    pages: internals.pagesByComponent,
    vite: viteBuildConfig,
    target: "server"
  });
  return await vite.build(viteBuildConfig);
}
async function clientBuild(opts, internals, input) {
  var _a, _b, _c, _d;
  const { astroConfig, viteConfig } = opts;
  const timer = performance.now();
  const ssr = isBuildingToSSR(astroConfig);
  const out = ssr ? opts.buildConfig.client : astroConfig.outDir;
  if (!input.size) {
    if (ssr) {
      await copyFiles(astroConfig.publicDir, out);
    }
    return null;
  }
  info(opts.logging, null, `
${bgGreen(black(" building client "))}`);
  const viteBuildConfig = {
    logLevel: "info",
    mode: "production",
    css: viteConfig.css,
    optimizeDeps: {
      include: [...((_a = viteConfig.optimizeDeps) == null ? void 0 : _a.include) ?? []],
      exclude: [...((_b = viteConfig.optimizeDeps) == null ? void 0 : _b.exclude) ?? []]
    },
    build: {
      emptyOutDir: false,
      minify: "esbuild",
      outDir: fileURLToPath(out),
      rollupOptions: {
        input: Array.from(input),
        output: __spreadValues({
          format: "esm",
          entryFileNames: "entry.[hash].js",
          chunkFileNames: "chunks/chunk.[hash].js",
          assetFileNames: "assets/asset.[hash][extname]"
        }, (_d = (_c = viteConfig.build) == null ? void 0 : _c.rollupOptions) == null ? void 0 : _d.output),
        preserveEntrySignatures: "exports-only"
      },
      target: "esnext"
    },
    plugins: [
      vitePluginInternals(input, internals),
      vitePluginHoistedScripts(astroConfig, internals),
      rollupPluginAstroBuildCSS({
        internals,
        target: "client"
      }),
      ...viteConfig.plugins || []
    ],
    publicDir: viteConfig.publicDir,
    root: viteConfig.root,
    envPrefix: "PUBLIC_",
    server: viteConfig.server,
    base: astroConfig.base
  };
  await runHookBuildSetup({
    config: astroConfig,
    pages: internals.pagesByComponent,
    vite: viteBuildConfig,
    target: "client"
  });
  const buildResult = await vite.build(viteBuildConfig);
  info(opts.logging, null, dim(`Completed in ${getTimeStat(timer, performance.now())}.
`));
  return buildResult;
}
async function cleanSsrOutput(opts) {
  const files = await glob("**/*.mjs", {
    cwd: fileURLToPath(opts.astroConfig.outDir)
  });
  await Promise.all(files.map(async (filename) => {
    const url = new URL(filename, opts.astroConfig.outDir);
    await fs.promises.rm(url);
  }));
}
async function copyFiles(fromFolder, toFolder) {
  const files = await glob("**/*", {
    cwd: fileURLToPath(fromFolder)
  });
  await Promise.all(files.map(async (filename) => {
    const from = new URL(filename, fromFolder);
    const to = new URL(filename, toFolder);
    const lastFolder = new URL("./", to);
    return fs.promises.mkdir(lastFolder, { recursive: true }).then(() => fs.promises.copyFile(from, to));
  }));
}
async function ssrMoveAssets(opts) {
  info(opts.logging, "build", "Rearranging server assets...");
  const serverRoot = opts.buildConfig.staticMode ? opts.buildConfig.client : opts.buildConfig.server;
  const clientRoot = opts.buildConfig.client;
  const serverAssets = new URL("./assets/", serverRoot);
  const clientAssets = new URL("./assets/", clientRoot);
  const files = await glob("assets/**/*", {
    cwd: fileURLToPath(serverRoot)
  });
  await fs.promises.mkdir(clientAssets, { recursive: true });
  await Promise.all(files.map(async (filename) => {
    const currentUrl = new URL(filename, serverRoot);
    const clientUrl = new URL(filename, clientRoot);
    return fs.promises.rename(currentUrl, clientUrl);
  }));
  removeDir(serverAssets);
}
export {
  staticBuild
};
