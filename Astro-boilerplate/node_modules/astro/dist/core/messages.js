import boxen from "boxen";
import {
  bgCyan,
  bgGreen,
  bgRed,
  bgWhite,
  bgYellow,
  black,
  bold,
  cyan,
  dim,
  green,
  red,
  underline,
  yellow
} from "kleur/colors";
import os from "os";
import { cleanErrorStack, collectErrorMetadata } from "./errors.js";
import { emoji, getLocalAddress, padMultilineString } from "./util.js";
const PREFIX_PADDING = 6;
function req({
  url,
  statusCode,
  reqTime
}) {
  let color = dim;
  if (statusCode >= 500)
    color = red;
  else if (statusCode >= 400)
    color = yellow;
  else if (statusCode >= 300)
    color = dim;
  else if (statusCode >= 200)
    color = green;
  return `${bold(color(`${statusCode}`.padStart(PREFIX_PADDING)))} ${url.padStart(40)} ${reqTime ? dim(Math.round(reqTime) + "ms") : ""}`.trim();
}
function reload({ file }) {
  return `${green("reload".padStart(PREFIX_PADDING))} ${file}`;
}
function hmr({ file }) {
  return `${green("update".padStart(PREFIX_PADDING))} ${file}`;
}
function devStart({
  startupTime,
  devServerAddressInfo,
  config,
  https,
  site
}) {
  const version = "1.0.0-beta.44";
  const rootPath = site ? site.pathname : "/";
  const localPrefix = `${dim("\u2503")} Local    `;
  const networkPrefix = `${dim("\u2503")} Network  `;
  const { address: networkAddress, port } = devServerAddressInfo;
  const localAddress = getLocalAddress(networkAddress, config.server.host);
  const networkLogging = getNetworkLogging(config.server.host);
  const toDisplayUrl = (hostname) => `${https ? "https" : "http"}://${hostname}:${port}${rootPath}`;
  let local = `${localPrefix}${bold(cyan(toDisplayUrl(localAddress)))}`;
  let network = null;
  if (networkLogging === "host-to-expose") {
    network = `${networkPrefix}${dim("use --host to expose")}`;
  } else if (networkLogging === "visible") {
    const ipv4Networks = Object.values(os.networkInterfaces()).flatMap((networkInterface) => networkInterface ?? []).filter((networkInterface) => (networkInterface == null ? void 0 : networkInterface.address) && (networkInterface == null ? void 0 : networkInterface.family) === "IPv4");
    for (let { address } of ipv4Networks) {
      if (address.includes("127.0.0.1")) {
        const displayAddress = address.replace("127.0.0.1", localAddress);
        local = `${localPrefix}${bold(cyan(toDisplayUrl(displayAddress)))}`;
      } else {
        network = `${networkPrefix}${bold(cyan(toDisplayUrl(address)))}`;
      }
    }
    if (!network) {
      network = `${networkPrefix}${dim("unable to find network to expose")}`;
    }
  }
  const messages = [
    `${emoji("\u{1F680} ", "")}${bgGreen(black(` astro `))} ${green(`v${version}`)} ${dim(`started in ${Math.round(startupTime)}ms`)}`,
    "",
    local,
    network,
    ""
  ];
  return messages.filter((msg) => typeof msg === "string").map((msg) => `  ${msg}`).join("\n");
}
function telemetryNotice() {
  const headline = yellow(`Astro now collects ${bold("anonymous")} usage data.`);
  const why = `This ${bold("optional program")} will help shape our roadmap.`;
  const more = `For more info, visit ${underline("https://astro.build/telemetry")}`;
  const box = boxen([headline, why, "", more].join("\n"), {
    margin: 0,
    padding: 1,
    borderStyle: "round",
    borderColor: "yellow"
  });
  return box;
}
function telemetryEnabled() {
  return `
  ${green("\u25C9")} Anonymous telemetry is ${bgGreen(black(" enabled "))}. Thank you for improving Astro!
`;
}
function telemetryDisabled() {
  return `
  ${yellow("\u25EF")}  Anonymous telemetry is ${bgYellow(black(" disabled "))}. We won't share any usage data.
`;
}
function telemetryReset() {
  return `
  ${cyan("\u25C6")} Anonymous telemetry has been ${bgCyan(black(" reset "))}. You may be prompted again.
`;
}
function fsStrictWarning() {
  return yellow("\u26A0\uFE0F Serving with vite.server.fs.strict: false. Note that all files on your machine will be accessible to anyone on your network!");
}
function prerelease({ currentVersion }) {
  const tag = currentVersion.split("-").slice(1).join("-").replace(/\..*$/, "");
  const badge = bgYellow(black(` ${tag} `));
  const headline = yellow(`\u25B6 This is a ${badge} prerelease build`);
  const warning = `  Feedback? ${underline("https://astro.build/issues")}`;
  return [headline, warning, ""].map((msg) => `  ${msg}`).join("\n");
}
function success(message, tip) {
  const badge = bgGreen(black(` success `));
  const headline = green(message);
  const footer = tip ? `
  \u25B6 ${tip}` : void 0;
  return ["", `${badge} ${headline}`, footer].filter((v) => v !== void 0).map((msg) => `  ${msg}`).join("\n");
}
function failure(message, tip) {
  const badge = bgRed(black(` error `));
  const headline = red(message);
  const footer = tip ? `
  \u25B6 ${tip}` : void 0;
  return ["", `${badge} ${headline}`, footer].filter((v) => v !== void 0).map((msg) => `  ${msg}`).join("\n");
}
function cancelled(message, tip) {
  const badge = bgYellow(black(` cancelled `));
  const headline = yellow(message);
  const footer = tip ? `
  \u25B6 ${tip}` : void 0;
  return ["", `${badge} ${headline}`, footer].filter((v) => v !== void 0).map((msg) => `  ${msg}`).join("\n");
}
function portInUse({ port }) {
  return `Port ${port} in use. Trying a new one\u2026`;
}
const LOCAL_IP_HOSTS = /* @__PURE__ */ new Set(["localhost", "127.0.0.1"]);
function getNetworkLogging(host) {
  if (host === false) {
    return "host-to-expose";
  } else if (typeof host === "string" && LOCAL_IP_HOSTS.has(host)) {
    return "none";
  } else {
    return "visible";
  }
}
function formatConfigErrorMessage(err) {
  const errorList = err.issues.map((issue) => `  ! ${bold(issue.path.join("."))}  ${red(issue.message + ".")}`);
  return `${red("[config]")} Astro found issue(s) with your configuration:
${errorList.join("\n")}`;
}
function formatErrorMessage(_err, args = []) {
  const err = collectErrorMetadata(_err);
  args.push(`${bgRed(black(` error `))}${red(bold(padMultilineString(err.message)))}`);
  if (err.hint) {
    args.push(`  ${bold("Hint:")}`);
    args.push(yellow(padMultilineString(err.hint, 4)));
  }
  if (err.id) {
    args.push(`  ${bold("File:")}`);
    args.push(red(`    ${err.id}`));
  }
  if (err.frame) {
    args.push(`  ${bold("Code:")}`);
    args.push(red(padMultilineString(err.frame, 4)));
  }
  if (args.length === 1 && err.stack) {
    args.push(dim(cleanErrorStack(err.stack)));
  } else if (err.stack) {
    args.push(`  ${bold("Stacktrace:")}`);
    args.push(dim(cleanErrorStack(err.stack)));
    args.push(``);
  }
  return args.join("\n");
}
function printHelp({
  commandName,
  headline,
  usage,
  commands,
  flags
}) {
  const linebreak = () => "";
  const title = (label) => `  ${bgWhite(black(` ${label} `))}`;
  const table = (rows, opts) => {
    const split = rows.some((row) => {
      const message2 = `${opts.prefix}${" ".repeat(opts.padding)}${row[1]}`;
      return message2.length > process.stdout.columns;
    });
    let raw = "";
    for (const row of rows) {
      raw += `${opts.prefix}${bold(`${row[0]}`.padStart(opts.padding - opts.prefix.length))}`;
      if (split)
        raw += "\n    ";
      raw += " " + dim(row[1]) + "\n";
    }
    return raw.slice(0, -1);
  };
  let message = [];
  if (headline) {
    message.push(linebreak(), `  ${bgGreen(black(` ${commandName} `))} ${green(`v${"1.0.0-beta.44"}`)} ${headline}`);
  }
  if (usage) {
    message.push(linebreak(), `  ${green(commandName)} ${bold(usage)}`);
  }
  if (commands) {
    message.push(linebreak(), title("Commands"), table(commands, { padding: 28, prefix: `  ${commandName || "astro"} ` }));
  }
  if (flags) {
    message.push(linebreak(), title("Flags"), table(flags, { padding: 28, prefix: "  " }));
  }
  console.log(message.join("\n"));
}
export {
  cancelled,
  devStart,
  failure,
  formatConfigErrorMessage,
  formatErrorMessage,
  fsStrictWarning,
  getNetworkLogging,
  hmr,
  portInUse,
  prerelease,
  printHelp,
  reload,
  req,
  success,
  telemetryDisabled,
  telemetryEnabled,
  telemetryNotice,
  telemetryReset
};
