var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
import { renderHead, renderPage } from "../../runtime/server/index.js";
import { getParams } from "../routing/params.js";
import { createResult } from "./result.js";
import { callGetStaticPaths, findPathItemByKey } from "./route-cache.js";
var GetParamsAndPropsError = /* @__PURE__ */ ((GetParamsAndPropsError2) => {
  GetParamsAndPropsError2[GetParamsAndPropsError2["NoMatchingStaticPath"] = 0] = "NoMatchingStaticPath";
  return GetParamsAndPropsError2;
})(GetParamsAndPropsError || {});
async function getParamsAndProps(opts) {
  const { logging, mod, route, routeCache, pathname, ssr } = opts;
  let params = {};
  let pageProps;
  if (route && !route.pathname) {
    if (route.params.length) {
      const paramsMatch = route.pattern.exec(pathname);
      if (paramsMatch) {
        params = getParams(route.params)(paramsMatch);
      }
    }
    let routeCacheEntry = routeCache.get(route);
    if (!routeCacheEntry) {
      routeCacheEntry = await callGetStaticPaths({ mod, route, isValidate: true, logging, ssr });
      routeCache.set(route, routeCacheEntry);
    }
    const matchedStaticPath = findPathItemByKey(routeCacheEntry.staticPaths, params);
    if (!matchedStaticPath && !ssr) {
      return 0 /* NoMatchingStaticPath */;
    }
    pageProps = (matchedStaticPath == null ? void 0 : matchedStaticPath.props) ? __spreadValues({}, matchedStaticPath.props) : {};
  } else {
    pageProps = {};
  }
  return [params, pageProps];
}
async function render(opts) {
  const {
    links,
    styles,
    logging,
    origin,
    markdown,
    mod,
    pathname,
    scripts,
    renderers,
    request,
    resolve,
    route,
    routeCache,
    site,
    ssr
  } = opts;
  const paramsAndPropsRes = await getParamsAndProps({
    logging,
    mod,
    route,
    routeCache,
    pathname,
    ssr
  });
  if (paramsAndPropsRes === 0 /* NoMatchingStaticPath */) {
    throw new Error(`[getStaticPath] route pattern matched, but no matching static path found. (${pathname})`);
  }
  const [params, pageProps] = paramsAndPropsRes;
  const Component = await mod.default;
  if (!Component)
    throw new Error(`Expected an exported Astro component but received typeof ${typeof Component}`);
  if (!Component.isAstroComponentFactory)
    throw new Error(`Unable to SSR non-Astro component (${route == null ? void 0 : route.component})`);
  const result = createResult({
    links,
    styles,
    logging,
    markdown,
    origin,
    params,
    props: pageProps,
    pathname,
    resolve,
    renderers,
    request,
    site,
    scripts,
    ssr
  });
  let page = await renderPage(result, Component, pageProps, null);
  if (page.type === "response") {
    return page;
  }
  let html = page.html;
  if (html.indexOf("<!--astro:head:injected-->") == -1) {
    html = await renderHead(result) + html;
  }
  html = html.replace("<!--astro:head:injected-->", "");
  if (!/<!doctype html/i.test(html)) {
    html = "<!DOCTYPE html>\n" + html;
  }
  return {
    type: "html",
    html,
    response: result.response
  };
}
export {
  GetParamsAndPropsError,
  getParamsAndProps,
  render
};
