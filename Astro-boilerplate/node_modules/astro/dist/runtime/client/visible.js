import { listen, notify } from "./events";
async function onVisible(astroId, options, getHydrateCallback) {
  let io;
  let innerHTML = null;
  let hydrate;
  async function visible() {
    listen(visible);
    const roots = document.querySelectorAll(`astro-root[ssr][uid="${astroId}"]`);
    const cb = async () => {
      var _a;
      if (roots.length === 0)
        return;
      if (typeof innerHTML !== "string") {
        let fragment = roots[0].querySelector(`astro-fragment`);
        if (fragment == null && roots[0].hasAttribute("tmpl")) {
          let template = roots[0].querySelector(`template[data-astro-template]`);
          if (template) {
            innerHTML = template.innerHTML;
            template.remove();
          }
        } else if (fragment) {
          innerHTML = fragment.innerHTML;
        }
      }
      if (!hydrate) {
        hydrate = await getHydrateCallback();
      }
      for (const root of roots) {
        if ((_a = root.parentElement) == null ? void 0 : _a.closest("astro-root[ssr]"))
          continue;
        await hydrate(root, innerHTML);
        root.removeAttribute("ssr");
      }
      notify();
    };
    if (io) {
      io.disconnect();
    }
    io = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        if (!entry.isIntersecting)
          continue;
        io.disconnect();
        cb();
        break;
      }
    });
    for (const root of roots) {
      for (let i = 0; i < root.children.length; i++) {
        const child = root.children[i];
        io.observe(child);
      }
    }
  }
  visible();
}
export {
  onVisible as default
};
