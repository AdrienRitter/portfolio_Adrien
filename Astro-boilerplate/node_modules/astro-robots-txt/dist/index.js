var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/index.ts
import { ZodError } from "zod";

// ../utils/src/is-object-empty.ts
var isObjectEmpty = (o) => {
  if (!o) {
    return true;
  }
  if (Array.isArray(o)) {
    return o.length === 0;
  }
  return Object.keys(o).length === 0 && Object.getPrototypeOf(o) === Object.prototype;
};

// ../utils/src/is-valid-hostname.ts
var isValidHostname = (x) => {
  if (typeof x !== "string") {
    return false;
  }
  let value = x.toString();
  const validHostnameChars = /^[a-zA-Z0-9-.]{1,253}\.?$/g;
  if (!validHostnameChars.test(value)) {
    return false;
  }
  if (value.endsWith(".")) {
    value = value.slice(0, value.length - 1);
  }
  if (value.length > 253) {
    return false;
  }
  return value.split(".").every((label) => /^([a-zA-Z0-9-]+)$/g.test(label) && label.length < 64 && !label.startsWith("-") && !label.endsWith("-"));
};

// ../utils/src/is-valid-http-url.ts
var isValidHttpUrl = (s) => {
  if (typeof s !== "string" || !s) {
    return false;
  }
  try {
    const { protocol } = new URL(s);
    return protocol === "http:" || protocol === "https:";
  } catch {
    return false;
  }
};

// ../utils/src/is-valid-url.ts
var isValidUrl = (s) => {
  if (typeof s !== "string" || !s) {
    return false;
  }
  try {
    const dummy = new URL(s);
    return true;
  } catch {
    return false;
  }
};

// ../utils/src/logger.ts
var Logger = class {
  constructor(packageName2) {
    this.colors = {
      reset: "\x1B[0m",
      fg: {
        red: "\x1B[31m",
        green: "\x1B[32m",
        yellow: "\x1B[33m"
      }
    };
    this.packageName = packageName2;
  }
  log(msg, prefix = "") {
    console.log(`%s${this.packageName}:%s ${msg}
`, prefix, prefix ? this.colors.reset : "");
  }
  info(msg) {
    this.log(msg);
  }
  success(msg) {
    this.log(msg, this.colors.fg.green);
  }
  warn(msg) {
    this.log(`Skipped!
${msg}`, this.colors.fg.yellow);
  }
  error(msg) {
    this.log(`Failed!
${msg}`, this.colors.fg.red);
  }
};

// ../utils/src/is-file-exists.ts
import fs from "fs";
async function isFileExists(file) {
  try {
    const result = await fs.promises.stat(file);
    return result.isFile();
  } catch (e) {
    if (e.code !== "ENOENT") {
      throw e;
    }
    return false;
  }
}

// ../utils/src/load-config.ts
async function loadConfig(namespace, base) {
  if (!namespace) {
    return null;
  }
  const exts = ["js", "mjs", "cjs"];
  for (const ext of exts) {
    const fileName = `${namespace}.config.${ext}`;
    const file = new URL(fileName, base);
    if (await isFileExists(file)) {
      const module = await import(file.pathname);
      if (!module.default) {
        throw new Error(`'${fileName}' doesn't contain a default export`);
      }
      return module.default;
    }
  }
  return null;
}

// src/index.ts
import merge from "deepmerge";

// src/data/pkg-name.ts
var packageName = "astro-robots-txt";

// src/on-build-done.ts
import fs2 from "fs";

// src/with-options.ts
var defaultOptions = {
  sitemap: true,
  policy: [
    {
      allow: "/",
      userAgent: "*"
    }
  ]
};
var withOptions = (pluginOptions) => {
  if (isObjectEmpty(pluginOptions)) {
    return defaultOptions;
  }
  const options = {
    host: pluginOptions == null ? void 0 : pluginOptions.host,
    sitemap: typeof (pluginOptions == null ? void 0 : pluginOptions.sitemap) === "undefined" ? true : pluginOptions.sitemap,
    policy: (pluginOptions == null ? void 0 : pluginOptions.policy) || defaultOptions.policy
  };
  return options;
};

// src/validate-opts.ts
import { z as z2 } from "zod";

// src/schema.ts
import { z } from "zod";
var validateSitemapItem = () => z.string().min(1).refine((val) => !val || isValidUrl(val), {
  message: "Not valid url"
}).refine((val) => !val || isValidHttpUrl(val), {
  message: "Only `http` or `https` protocol allowed"
});
var validateCleanParam = () => z.string().max(500);
var RobotsTxtOptionsSchema = z.object({
  host: z.string().optional().refine((val) => !val || isValidHostname(val), {
    message: "Not valid host"
  }),
  sitemap: validateSitemapItem().or(validateSitemapItem().array()).or(z.boolean()).optional().default(true),
  policy: z.object({
    userAgent: z.string().min(1),
    allow: z.string().or(z.string().array()).optional(),
    disallow: z.string().or(z.string().array()).optional(),
    cleanParam: validateCleanParam().or(validateCleanParam().array()).optional(),
    crawlDelay: z.number().nonnegative().refine((val) => typeof val === "undefined" || Number.isFinite(val), { message: "Must be finite number" }).optional()
  }).array().nonempty().optional()
});

// src/validate-opts.ts
var validateOpts = (site, opts) => {
  const schema = RobotsTxtOptionsSchema.extend({
    site: z2.string().min(1, {
      message: "`site` property is required in `astro.config.*`."
    })
  });
  schema.parse(__spreadValues({ site: site || "" }, opts || {}));
};

// src/get-robots-txt-content.ts
var capitaliseFirstLetter = (s) => s.charAt(0).toUpperCase() + s.slice(1);
var addBackslash = (s) => s.endsWith("/") ? s : `${s}/`;
var addLine = (name, rule) => {
  if (rule && Array.isArray(rule) && rule.length > 0) {
    let contents = "";
    rule.forEach((item) => {
      contents += addLine(name, item);
    });
    return contents;
  }
  const ruleContent = name === "Allow" || name === "Disallow" ? encodeURI(rule.toString()) : rule.toString();
  return `${capitaliseFirstLetter(name.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase())}:${ruleContent.length > 0 ? ` ${ruleContent}` : ""}
`;
};
var generatePoliceItem = (item, index) => {
  let contents = "";
  if (index !== 0) {
    contents += "\n";
  }
  contents += addLine("User-agent", item.userAgent);
  if (typeof item.disallow === "string" || Array.isArray(item.disallow)) {
    contents += addLine("Disallow", item.disallow);
  }
  if (item.allow) {
    contents += addLine("Allow", item.allow);
  }
  if (item.crawlDelay) {
    contents += addLine("Crawl-delay", item.crawlDelay);
  }
  if (item.cleanParam && item.cleanParam.length > 0) {
    contents += addLine("Clean-param", item.cleanParam);
  }
  return contents;
};
var getSitemapArr = (sitemap, site) => {
  if (typeof sitemap !== "undefined") {
    if (!sitemap) {
      return void 0;
    }
    if (Array.isArray(sitemap)) {
      return sitemap;
    }
    if (typeof sitemap === "string") {
      return [sitemap];
    }
  }
  return [`${addBackslash(site)}sitemap.xml`];
};
var getRobotsTxtContent = (site, { host, sitemap, policy } = {}) => {
  var _a;
  let result = "";
  policy == null ? void 0 : policy.forEach((item, index) => {
    result += generatePoliceItem(item, index);
  });
  (_a = getSitemapArr(sitemap, site)) == null ? void 0 : _a.forEach((item) => {
    result += addLine("Sitemap", item);
  });
  if (host) {
    result += addLine("Host", host);
  }
  return result;
};

// src/on-build-done.ts
var onBuildDone = (pluginOptions, config, dir) => {
  const opts = withOptions(pluginOptions);
  validateOpts(config.site, opts);
  const robotsTxtContent = getRobotsTxtContent(config.site, opts);
  const url = new URL("robots.txt", dir);
  fs2.writeFileSync(url, robotsTxtContent);
};
var on_build_done_default = onBuildDone;

// src/index.ts
function formatConfigErrorMessage(err) {
  const errorList = err.issues.map((issue) => ` ${issue.path.join(".")}  ${issue.message + "."}`);
  return errorList.join("\n");
}
var createPlugin = (options) => {
  let config;
  return {
    name: packageName,
    hooks: {
      "astro:config:done": async ({ config: cfg }) => {
        config = cfg;
      },
      "astro:build:done": async ({ dir }) => {
        const namespace = packageName.replace("astro-", "");
        const external = await loadConfig(namespace, config.root);
        const merged = merge(external || {}, options || {});
        const logger = new Logger(packageName);
        try {
          on_build_done_default(merged, config, dir);
          logger.success("`robots.txt` is created.");
        } catch (err) {
          if (err instanceof ZodError) {
            logger.warn(formatConfigErrorMessage(err));
          } else {
            throw err;
          }
        }
      }
    }
  };
};
var src_default = createPlugin;
export {
  src_default as default
};
